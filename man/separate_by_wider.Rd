% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/separate-wider.R
\name{separate_by_wider}
\alias{separate_by_wider}
\alias{separate_at_wider}
\alias{separate_regex_wider}
\title{Split a string into columns}
\usage{
separate_by_wider(
  data,
  cols,
  sep,
  ...,
  names = NULL,
  names_sep = NULL,
  names_repair = "check_unique",
  align_short = c("error", "debug", "start", "end"),
  align_long = c("error", "debug", "drop", "merge"),
  col_remove = TRUE
)

separate_at_wider(
  data,
  cols,
  widths,
  ...,
  names_sep = NULL,
  names_repair = "check_unique",
  align_short = c("error", "debug", "start"),
  align_long = c("error", "debug", "drop"),
  col_remove = TRUE
)

separate_regex_wider(
  data,
  cols,
  patterns,
  ...,
  names_sep = NULL,
  names_repair = "check_unique",
  align_short = c("error", "debug", "start"),
  col_remove = TRUE
)
}
\arguments{
\item{data}{A data frame.}

\item{cols}{<\code{\link[=tidyr_tidy_select]{tidy-select}}> Columns to separate.}

\item{sep}{Separator between columns, by default, a fixed string.
Use \code{stringr::regexp()} and friends to split in other ways.}

\item{...}{Additional arguments passed on to methods.}

\item{names, names_sep}{If you are separating a single column, specify either
a fixed number of column \code{names} or use \code{names_sep} to generate new names
from the source column name, \code{names_sep}, and a numeric suffix.

If you are separating multiple columns, you must to supply \code{names_sep},
to avoid creating duplicated column names.}

\item{names_repair}{Used to check that output data frame has valid
names. Must be one of the following options:
\itemize{
\item "minimal": no name repair or checks, beyond basic existence,
\item "unique": make sure names are unique and not empty,
\item "check_unique": (the default), no name repair, but check they are unique,
\item "universal": make the names unique and syntactic
\item a function: apply custom name repair.
\item \link{tidyr_legacy}: use the name repair from tidyr 0.8.
\item a formula: a purrr-style anonymous function (see \code{\link[rlang:as_function]{rlang::as_function()}})
}

See \code{\link[vctrs:vec_as_names]{vctrs::vec_as_names()}} for more details on these terms and the
strategies used to enforce them.}

\item{align_short}{What should happen if a value separates into too few
pieces?
\itemize{
\item \code{"error"}, the default, will throw an error.
\item \code{"debug"} will add additional columns to the output to help you
locate and resolve the underlying problem.
\item \code{"start"} will the align starts of short matches, adding \code{NA} on the end
to pad to the correct length.
\item \code{"end"} (\code{separate_by_wider()} only) will align the ends of short
matches, adding \code{NA} at the start to pad to the correct length.
}}

\item{align_long}{What should happen if a value separates into too many
pieces?
\itemize{
\item \code{"error"}, the default, will throw an error.
\item \code{"debug"} will add additional columns to the output to help you
locate and resolve the underlying problem.
\item \code{"drop"} will silently drop any extra pieces.
\item \code{"merge"} (\code{separate_by_wider()} only) will merge together any
additional pieces.
}}

\item{col_remove}{Should the input \code{cols} be removed from the output?
Always preserved if \code{align_short} or \code{align_long} is set to \verb{"debug}.}

\item{widths}{A named numeric vector where the names become column names,
and the values specify the column width. Unnamed components will match,
but not be included in the output.}

\item{patterns}{A named character vector where the names become column names
and the values are regular expressions that match the contents of the
vector. Unnamed components will match, but not be included in the output.}
}
\value{
A data frame, with the same number of rows as \code{df} but different
columns:
\itemize{
\item For \code{separate_by_wider()} the names of new columns come from \code{names}.
For \code{separate_at_wider()} the names come from the names of \code{widths}.
For \code{separate_regex_wider()} the names come from the names of
\code{patterns}. If \code{names_sep} is set, the output names will be created by
combining the original col name, with the names described above.
\item If \code{align_short} or \code{align_long} is \code{"debug"}, the ouput will additional
columns useful for debugging:
\itemize{
\item \verb{\{col\}_ok}: a logical vector which tells you if the input was ok or
not. Use to quickly find the problematic rows.
\item \verb{\{col\}_remainder}: any text remaining after separation.
\item \verb{\{col\}_pieces}, \verb{\{col\}_width}, \verb{\{col\}_matches}: number of pieces,
number of characters, and number of matches for \code{separate_by_wider()},
\code{separate_at_wider()} and \code{separate_regexp_wider()} respectively.
}
\item If \code{col_remove = TRUE} (the default), the input \code{cols} will be removed
from the output.
}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Each of these functions takes a string column and splits it into multiple
new columns:
\itemize{
\item \code{separate_by_wider()} splits with a delimiter.
\item \code{separate_at_wider()} splits using fixed widths.
\item \code{separate_regex_wider()} splits using regular expression matches.
}

These functions are equivalent to \code{\link[=separate]{separate()}} and \code{\link[=extract]{extract()}}, but use
\href{http://stringr.tidyverse.org/}{stringr} as the underlying string
manipulation engine, and their interfaces reflect what we've learned from
\code{\link[=unnest_wider]{unnest_wider()}} and \code{\link[=unnest_longer]{unnest_longer()}}.
}
\examples{
df <- tibble(id = 1:3, x = c("m-123", "f-455", "f-123"))
# There are three basic ways to split up a string into pieces.
# * with a delimiter
df \%>\% separate_by_wider(x, sep = "-", names = c("gender", "unit"))
# * by length
df \%>\% separate_at_wider(x, c(gender = 1, 1, unit = 3))
# * defining each component with a regular expression
df \%>\% separate_regex_wider(x, c(gender = ".", ".", unit = "\\\\d+"))

# Sometimes you split on the "last" delimiter:
df <- data.frame(var = c("race_1", "race_2", "age_bucket_1", "age_bucket_2"))
# _delim won't help because it always splits on the first delimiter
try(df \%>\% separate_by_wider(var, "_", names = c("var1", "var2")))
df \%>\% separate_by_wider(var, "_", names = c("var1", "var2"), align_long = "merge")
# Instead, you can use _group:
df \%>\% separate_regex_wider(var, c(var1 = ".*", "_", var2 = ".*"))
# this works because * is greedy; you can mimic the _by behaviour with .*?
df \%>\% separate_regex_wider(var, c(var1 = ".*?", "_", var2 = ".*"))

# If the number of components varies, it's most natural to split into rows
df <- tibble(id = 1:4, x = c("x", "x y", "x y z", NA))
df \%>\% separate_by_longer(x, sep = " ")
# But separate_by_wider() provides some tools to deal with the problem
# The default behaviour tells you that there's a problem
try(df \%>\% separate_by_wider(x, sep = " ", names = c("a", "b")))
# You can get additional insight by using the debug options:
df \%>\%
  separate_by_wider(
    x,
    sep = " ",
    names = c("a", "b"),
    align_short = "debug",
    align_long = "debug"
  )

# But you can can suppress the warnings:
df \%>\%
  separate_by_wider(
    x,
    sep = " ",
    names = c("a", "b"),
    align_short = "start",
    align_long = "merge"
  )

# Or choose to automatically name the columns, producing as many as needed
df \%>\% separate_by_wider(x, sep = " ", names_sep = "", align_short = "start")
}
