% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/separate-wider.R
\name{separate_by_wider}
\alias{separate_by_wider}
\alias{separate_at_wider}
\alias{separate_group_wider}
\title{Split a string into columns}
\usage{
separate_by_wider(
  data,
  cols,
  delim,
  ...,
  names = NULL,
  names_sep = NULL,
  names_repair = "check_unique",
  align_direction = c("start", "end"),
  align_warn = c("both", "short", "long", "none")
)

separate_at_wider(
  data,
  cols,
  widths,
  ...,
  names_sep = NULL,
  names_repair = "check_unique",
  align_direction = c("start", "end"),
  align_warn = c("both", "short", "long", "none")
)

separate_group_wider(
  data,
  cols,
  patterns,
  ...,
  match_complete = TRUE,
  names_sep = NULL,
  names_repair = "check_unique"
)
}
\arguments{
\item{data}{A data frame.}

\item{cols}{<\code{\link[=tidyr_tidy_select]{tidy-select}}> Columns to separate into
pieces.}

\item{delim}{Delimiter between columns, a stringr pattern.

Note that the default is a regular expression so that \code{delim = "."} will
split on every character. If you need to split by a special character, use
\code{delim = stringr::fixed(".")}.}

\item{...}{Additional arguments passed on to methods.}

\item{names, names_sep}{If you are separating a single column, specify either
a fixed number of column \code{names} or use \code{names_sep} to generate new names
from the source column name and a numeric suffix.

If you are separating multiple columns, you must to supply \code{names_sep},
to avoid creating duplicated column names.}

\item{names_repair}{Used to check that output data frame has valid
names. Must be one of the following options:
\itemize{
\item "minimal": no name repair or checks, beyond basic existence,
\item "unique": make sure names are unique and not empty,
\item "check_unique": (the default), no name repair, but check they are unique,
\item "universal": make the names unique and syntactic
\item a function: apply custom name repair.
\item \link{tidyr_legacy}: use the name repair from tidyr 0.8.
\item a formula: a purrr-style anonymous function (see \code{\link[rlang:as_function]{rlang::as_function()}})
}

See \code{\link[vctrs:vec_as_names]{vctrs::vec_as_names()}} for more details on these terms and the
strategies used to enforce them.}

\item{align_direction}{If different rows have different numbers of
observations should the \code{start}s or the \code{ends}s be aligned?}

\item{align_warn}{When do you want to be informed about strings that have
too many or too few pieces?
\itemize{
\item \code{"both"}, the default, when there are too few or too many.
\item \code{"short"}, only when there are too few.
\item \code{"long"}, only where there are too many.
\item \code{"none"}, never warn.
}}

\item{widths}{A named numeric vector where the names become column names,
and the values specify the column width. Omit the name to leave those
values out of the final output.}

\item{patterns}{A named character vector where the names given names of
new columns in the output, and the values are regular expressions.
Unnamed components will match, but not be included in the output.}

\item{match_complete}{Is the pattern required to match the entire string?}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Each of these functions takes a string column and splits it into multiple
new columns:
\itemize{
\item \code{separate_by_wider()} splits with a delimiter.
\item \code{separate_at_wider()} splits using fixed widths.
\item \code{separate_group_wider()} splits using regular expression matches.
}

These functions are equivalent to \code{\link[=separate]{separate()}} and \code{\link[=extract]{extract()}}, but use
\href{http://stringr.tidyverse.org/}{stringr} as the underlying string
manipulation engine, and their interfaces reflect what we've learned from
\code{\link[=unnest_wider]{unnest_wider()}} and \code{\link[=unnest_longer]{unnest_longer()}}.
}
\examples{
df <- tibble(id = 1:3, x = c("m-123", "f-455", "f-123"))
# There are three basic ways to split up a string into pieces.
# * with a delimiter
df \%>\% separate_by_wider(x, delim = "-", c("gender", "unit"))
# * by length
df \%>\% separate_at_wider(x, c(gender = 1, 1, unit = 3))
# * defining each component with a regular expression
df \%>\% separate_group_wider(x, c(gender = ".", ".", unit = "\\\\d+"))

# Sometimes you split on the "last" delimiter:
df <- data.frame(var = c("race_1", "race_2", "age_bucket_1", "age_bucket_2"))
# _delim won't help because it always splits on the first delimiter
df \%>\% separate_by_wider(var, "_", names = c("var1", "var2"))
# Instead, you can use _group:
df \%>\% separate_group_wider(var, c(var1 = ".*", "_", var2 = ".*"))
# this works because * is greedy; you can mimic the _by behaviour with .*?
df \%>\% separate_group_wider(var, c(var1 = ".*?", "_", var2 = ".*"))

# If the number of components varies, it's most natural to split into rows
df <- tibble(id = 1:4, x = c("x", "x y", "x y z", NA))
df \%>\% separate_by_longer(x, delim = " ")
# But separate_by_wider() provides some tools to deal with the problem
# The default behaviour tells you where the problems lie:
df \%>\% separate_by_wider(x, delim = " ", names = c("a", "b"))
# But you can can suppress the warnings:
df \%>\% separate_by_wider(x, c("a", "b"), delim = " ", align_warn = "none")
# Or choose to automatically name the columns
df \%>\% separate_by_wider(x, delim = " ", names_sep = "", align_warn = "none")
}
