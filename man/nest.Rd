% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nest.R
\name{nest}
\alias{nest}
\title{Nest rows into a list-column of data frames}
\usage{
nest(.data, ..., .names_sep = NULL, .key = deprecated())
}
\arguments{
\item{.data}{A data frame.}

\item{...}{<\code{\link[=tidyr_tidy_select]{tidy-select}}> Columns to nest, specified
using name-variable pairs of the form \code{new_col = c(col1, col2, col3)}.
The right hand side can be any valid tidyselect expression.

\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}}:
previously you could write \code{df \%>\% nest(x, y, z)}.
Convert to \code{df \%>\% nest(data = c(x, y, z))}.}

\item{.names_sep}{If \code{NULL}, the default, the inner names will come from
the former outer names. If a string, the  new inner names will use the
outer names with \code{names_sep} automatically stripped. This makes
\code{names_sep} roughly symmetric between nesting and unnesting.}

\item{.key}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}}:
No longer needed because of the new \code{new_col = c(col1, col2, col3)} syntax.}
}
\description{
Nesting creates a list-column of data frames; unnesting flattens it back out
into regular columns. Nesting is implicitly a summarising operation: you
get one row for each group defined by the non-nested columns. This is useful
in conjunction with other summaries that work with whole datasets, most
notably models.

Learn more in \code{vignette("nest")}.
}
\section{New syntax}{

tidyr 1.0.0 introduced a new syntax for \code{nest()} and \code{unnest()} that's
designed to be more similar to other functions. Converting to the new syntax
should be straightforward (guided by the message you'll recieve) but if
you just need to run an old analysis, you can easily revert to the previous
behaviour using \code{\link[=nest_legacy]{nest_legacy()}} and \code{\link[=unnest_legacy]{unnest_legacy()}} as follows:

\if{html}{\out{<div class="sourceCode">}}\preformatted{library(tidyr)
nest <- nest_legacy
unnest <- unnest_legacy
}\if{html}{\out{</div>}}
}

\section{Grouped data frames}{

\code{df \%>\% nest(data = c(x, y))} specifies the columns to be nested; i.e. the
columns that will appear in the inner data frame. Alternatively, you can
\code{nest()} a grouped data frame created by \code{\link[dplyr:group_by]{dplyr::group_by()}}. The grouping
variables remain in the outer data frame and the others are nested. The
result preserves the grouping of the input.

Variables supplied to \code{nest()} will override grouping variables so that
\code{df \%>\% group_by(x, y) \%>\% nest(data = !z)} will be equivalent to
\code{df \%>\% nest(data = !z)}.
}

\examples{
df <- tibble(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)
# Note that we get one row of output for each unique combination of
# non-nested variables
df \%>\% nest(data = c(y, z))
# chop does something similar, but retains individual columns
df \%>\% chop(c(y, z))

# use tidyselect syntax and helpers, just like in dplyr::select()
df \%>\% nest(data = any_of(c("y", "z")))

iris \%>\% nest(data = !Species)
nest_vars <- names(iris)[1:4]
iris \%>\% nest(data = any_of(nest_vars))
iris \%>\%
  nest(petal = starts_with("Petal"), sepal = starts_with("Sepal"))
iris \%>\%
  nest(width = contains("Width"), length = contains("Length"))

# Nesting a grouped data frame nests all variables apart from the group vars
fish_encounters \%>\%
  dplyr::group_by(fish) \%>\%
  nest()

# Nesting is often useful for creating per group models
mtcars \%>\%
  dplyr::group_by(cyl) \%>\%
  nest() \%>\%
  dplyr::mutate(models = lapply(data, function(df) lm(mpg ~ wt, data = df)))
}
